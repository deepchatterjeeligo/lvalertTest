#!/usr/bin/python
usage       = "lvalert_listen [--options]"
description = "a script that monitors a fakeDB_directory for new lvalert messages and destributes forks processes like lvalert_listen would"
author      = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import sys
import subprocess as sp

import multiprocessing as mp
import tempfile

from ligoTest.lvalert import lvalertTestUtils as utils

from ConfigParser import SafeConfigParser

from optparse import OptionParser

#-------------------------------------------------

def forked_wait(cmd, file_obj):
    """
    used with the "--dont-wait" option to avoid zombie processes via a double fork
    main process will wait for this function to finish (quick), send the "wait" signal
    which removes this function from the process table, and then moves on.
    the forked process that this function creates become orphaned, and will automatically
    be removed from the process table upon completion.
    """
    sp.Popen(cmd, stdin=file_obj, stdout=sys.stdout, stderr=sys.stderr)


def alert2listener( node, message, node2cmd={}, verbose=False, dont_wait=False ):
    '''
    forks a process via subprocess
    signature is specified within lvalertTestUtils
    '''
    if node2cmd.has_key(node):
        if dont_wait:
            file_obj = tempfile.SpooledTemporaryFile(mode="w+r", max_size=1000)
            file_obj.write(message)
            file_obj.readlines() ### bug fix for "alert_type"=="new" events
                                 ### without this, the position in file_obj gets messed up
                                 ### no idea why, but it might be related to long messages becoming multiple stanzas
            file_obj.seek(0, 0)
            p = multiprocessing.Process(target=forked_wait, args=(node2cmd[node], file_obj))
            p.start()
            p.join()
            file_obj.close()

        else:
            print sp.Popen( node2cmd[node], stdin=sp.PIPE, stdout=sp.PIPE ).communicate(message)[0] ### we don't capture the output because lvalert_listen does not

#-------------------------------------------------

parser = OptionParser(usage=usage, description=description)

parser.add_option('-v', '--verbose', default=False, action='store_true')

parser.add_option('-f', '--fakeDB-dir', default='.', type='string', help='the directory which FakeDb is managing')
parser.add_option('-C', '--command-filename', default=None, type='string', help='the file into which lvalert commands must be written')

parser.add_option('-c', "--config_file", default=None, type='string', help='config file with list of actions')

parser.add_option('--dont-wait', default=False, action='store_true')

parser.add_option('--cadence', default=0.1, type='float', help='how often we check lvalert.out for new messages')

opts, args = parser.parse_args()

lvalertSrc = os.path.join(opts.fakeDB_dir, 'lvalert.out')
if not os.path.exists(lvalertSrc):
    raise ValueError('could not find lvalert.out file corresponding to --fakeDB-dir : %s'%lvalertSrc)
trackThese = [lvalertSrc]

if opts.command_filename:
    if not os.path.exists(opts.command_filename):
        raise ValueError('could not find --command-filename=%s'%opts.command_filename)
    trackThese.append(opts.command_filename)

#-------------------------------------------------

node2cmd = dict()
if opts.config_file:
    if opts.verbose:
        print "reading config : %s"%opts.config_file
    config = SafeConfigParser()
    config.read(opts.config_file)

    if opts.verbose:
        print "setting up mapping between nodes and commands"

    for section in config.sections():
        if config.has_option(section, 'executable'):
            cmd = config.get(section, 'executable').split()

        elif config.has_option(section, 'executible'):
            cmd = config.get(section, 'executible')

        else:
            raise ValueError('mal-formed config file!')

        node2cmd[section] = cmd

#-------------------------------------------------

if opts.verbose:
    print "monitoring : %s"%(", ".join(trackThese))
    print "  cadence  : %.3f"%opts.cadence

buf = utils.LVAlertBuffer( trackThese )
buf.monitor( alert2listener, cadence=opts.cadence, node2cmd=node2cmd, verbose=opts.verbose, dont_wait=opts.dont_wait )
