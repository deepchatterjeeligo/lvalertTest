#!/usr/bin/python
usage       = "lvalert_listen [--options] config"
description = "a script that monitors a fakeDB_directory for new lvalert messages and destributes forks processes like lvalert_listen would"
author      = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import subprocess as sp

import multiprocessing as mp
import tempfile

from ligoTest.lvalert import lvalertTestUtils as utils

from ConfigParser import SafeConfigParser

from optparse import OptionParser

#-------------------------------------------------

def forked_wait(cmd, file_obj):
    """
    used with the "--dont-wait" option to avoid zombie processes via a double fork
    main process will wait for this function to finish (quick), send the "wait" signal
    which removes this function from the process table, and then moves on.
    the forked process that this function creates become orphaned, and will automatically
    be removed from the process table upon completion.
    """
    sp.Popen(cmd, stdin=file_obj)


def alert2listenr( node, message, node2cmd, verbose=False, dont_wait=False ):
    '''
    forks a process via subprocess
    signature is specified within lvalertTestUtils
    '''
    if dont_wait:
        file_obj = tempfile.SpooledTemporaryFile(mode="w+r", max_size=1000)
        file_obj.write(message)
        file_obj.readlines() ### bug fix for "alert_type"=="new" events
                             ### without this, the position in file_obj gets messed up
                             ### no idea why, but it might be related to long messages becoming multiple stanzas
        file_obj.seek(0, 0)
        p = multiprocessing.Process(target=forked_wait, args=(node2cmd[node], file_obj))
        p.start()
        p.join()
        file_obj.close()

    else:
        sp.Popen( node2cmd[node], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE).communicate(message) ### we don't capture the output because lvalert_listen does not

#-------------------------------------------------

parser = OptionParser(usage=usage, description=description)

parser.add_option('-v', '--verbose', default=False, action='store_true')

parser.add_option('-f', '--fakeDB-dir', default='.', type='string', help='the directory which FakeDb is managing')

parser.add_option('--dont-wait', default=False, action='store_true')

opts, args = parser.parse_args()

if len(args)!=1:
    raise ValueError('please supply exactly one argument\n%s'%usage)
configFilename = args[0]

lvalertSrc = os.path.join(opts.fakeDB_dir, 'lvalert.out')
if not os.path.exists(lvalertSrc):
    raise ValueError('could not find lvalert.out file corresponding to --fakeDB-dir : %s'%lvalertSrc)

#-------------------------------------------------

if opts.verbose:
    print "reading config : %s"%configFilename
config = SafeConfigParser()
config.read(configFilename)

#-------------------------------------------------

if opts.verbose:
    print "setting up mapping between nodes and commands"

node2cmd = dict()
for section in config.sections():
    if config.has_option(section, 'executable'):
        cmd = config.get(section, 'executable').split()

    elif config.has_option(section, 'executible'):
        cmd = config.get(section, 'executible')

    else:
        raise ValueError('mal-formed config file!')

    node2cmd[section] = cmd

#-------------------------------------------------

if opts.verbose:
    print "monitoring : %s"%lvalertSrc
    print "  cadence  : %.3f"%opts.cadence

buf = utils.LVAlertBuffer( lvalertSrc )
buf.monitor( alert2listener, config, cadence=opts.cadence, verbose=opts.verbose, dont_wait=opts.dont_wait )
